import { PromptPerfectClient, PromptPerfectRawInput, PromptPerfectOptions, PromptPerfectOutput } from './clients/PromptPerfectClient';
import { SceneXClient, SceneXRawInput, SceneXOptions, SceneXOutput, SceneXStoryOutput, SceneXSVideoOutput } from './clients/SceneXClient';
import { RationaleClient, RationaleRawInput, RationaleOptions, RationaleOutput } from './clients/RationaleClient';
import { JinaChatClient, JinaChatRawInput, JinaChatOptions, JinaChatOutput } from './clients/JinaChatClient';
import { BestBannerClient, BestBannerRawInput, BestBannerOptions, BestBannerOutput } from './clients/BestBannerClient';
import { HTTPClient } from './clients/HTTPClient';
export * from './clients/HTTPClient';
export * from './clients/JinaChatClient';
export * from './clients/PromptPerfectClient';
export * from './clients/RationaleClient';
export * from './clients/SceneXClient';
export * from './shared-types';
export type JinaAIParams = {
    secrets?: Partial<Record<'scenex-secret' | 'promptperfect-secret' | 'rationale-secret' | 'jinachat-secret' | 'bestbanner-secret', string>>;
    options?: Record<string, any>;
    baseUrls?: Partial<Record<'scenex' | 'promptperfect' | 'rationale' | 'jinachat' | 'bestbanner', string>>;
};
declare class JinaAI {
    PPClient: PromptPerfectClient;
    SXClient: SceneXClient;
    RAClient: RationaleClient;
    CCClient: JinaChatClient;
    BBClient: BestBannerClient;
    constructor(params?: JinaAIParams);
    decide(input: RationaleRawInput | Array<string> | string, options?: RationaleOptions): Promise<RationaleOutput>;
    optimize(input: PromptPerfectRawInput | Array<string> | string, options?: PromptPerfectOptions): Promise<PromptPerfectOutput>;
    describe<T extends SceneXOptions>(input: SceneXRawInput | Array<string> | string, options?: T): Promise<T['algorithm'] extends 'Hearth' ? (SceneXOutput & {
        results: Array<{
            i18n: {
                [key: string]: SceneXStoryOutput;
            };
        }>;
    }) : (T['algorithm'] extends 'Inception' ? (SceneXOutput & {
        results: Array<{
            i18n: {
                [key: string]: SceneXSVideoOutput;
            };
        }>;
    }) : (SceneXOutput & {
        results: Array<{
            i18n: {
                [key: string]: string;
            };
        }>;
    }))>;
    generate<T extends JinaChatOptions>(input: JinaChatRawInput | Array<string> | string, options?: T): Promise<T['stream'] extends true ? ReadableStreamDefaultReader : JinaChatOutput>;
    imagine(input: BestBannerRawInput | Array<string> | string, options?: BestBannerOptions): Promise<BestBannerOutput>;
    static utils: {
        isUrl: typeof import("./utils").isUrl;
        isBase64: typeof import("./utils").isBase64;
    };
    utils: {
        isUrl: typeof import("./utils").isUrl;
        isBase64: typeof import("./utils").isBase64;
    };
    static HTTPClient: typeof HTTPClient;
    static BestBannerClient: typeof BestBannerClient;
    static JinaChatClient: typeof JinaChatClient;
    static SceneXClient: typeof SceneXClient;
    static RationaleClient: typeof RationaleClient;
    static PromptPerfectClient: typeof PromptPerfectClient;
}
export default JinaAI;
