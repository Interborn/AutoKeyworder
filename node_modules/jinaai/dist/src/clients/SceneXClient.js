"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneXClient = exports.autoFillFeatures = void 0;
var tslib_1 = require("tslib");
var utils_1 = require("../utils");
var HTTPClient_1 = require("./HTTPClient");
var autoFillFeatures = function (options) {
    var features = (options === null || options === void 0 ? void 0 : options.features) || [];
    if ((options === null || options === void 0 ? void 0 : options.question) && features.includes('question_answer') == false)
        features.push('question_answer');
    return features;
};
exports.autoFillFeatures = autoFillFeatures;
var SceneXClient = (function (_super) {
    tslib_1.__extends(SceneXClient, _super);
    function SceneXClient(params) {
        var headers = params.headers, options = params.options, _a = params.baseURL, baseURL = _a === void 0 ? 'https://api.scenex.jina.ai/v1' : _a;
        var defaultHeaders = {
            'Content-Type': 'application/json',
        };
        var mergedHeaders = tslib_1.__assign(tslib_1.__assign({}, defaultHeaders), headers);
        return _super.call(this, { baseURL: baseURL, headers: mergedHeaders, options: options || {} }) || this;
    }
    SceneXClient.prototype.fromArray = function (input, options) {
        return {
            data: input.map(function (i) { return (tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ image: i }, (options && options.algorithm == 'Inception' && { video: i })), { features: (0, exports.autoFillFeatures)(options) }), options)); })
        };
    };
    SceneXClient.prototype.fromString = function (input, options) {
        return {
            data: [tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ image: input }, (options && options.algorithm == 'Inception' && { video: input })), { features: (0, exports.autoFillFeatures)(options) }), options)]
        };
    };
    SceneXClient.prototype.isOutput = function (obj) {
        return typeof obj === 'object' &&
            obj.result &&
            obj.result.every(function (x) { return x.image || x.video; });
    };
    SceneXClient.prototype.toSimplifiedOutout = function (output) {
        if (!output.result || output.result.every(function (x) { return x.image || x.video; }) == false)
            throw 'Remote API Error, bad output: ' + JSON.stringify(output);
        return {
            results: output.result.map(function (r) {
                var _a;
                return ({
                    output: r.answer ? r.answer : r.text || 'Processing...',
                    i18n: r.i18n,
                    tts: r.tts || undefined,
                    ssml: ((_a = r.dialog) === null || _a === void 0 ? void 0 : _a.ssml) || undefined,
                });
            })
        };
    };
    SceneXClient.prototype.describeVideo = function (output, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, Promise.all(output.result.map(function (scene, i) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var rawOutput, isDone, progress, e_1;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 5, , 6]);
                                        rawOutput = null;
                                        isDone = false;
                                        _a.label = 1;
                                    case 1:
                                        if (!(isDone == false)) return [3, 4];
                                        return [4, this.get("/scene/".concat(scene.id))];
                                    case 2:
                                        rawOutput = _a.sent();
                                        if (options === null || options === void 0 ? void 0 : options.reportProgress) {
                                            progress = "".concat(rawOutput.result.data.status || 'pending', " - ").concat(rawOutput.result.data.progress || '???');
                                            options.reportProgress(i, progress);
                                        }
                                        if (rawOutput.result.data.status != 'pending')
                                            isDone = true;
                                        return [4, (0, utils_1.sleep)(10000)];
                                    case 3:
                                        _a.sent();
                                        return [3, 1];
                                    case 4:
                                        if (rawOutput)
                                            output.result[i] = rawOutput === null || rawOutput === void 0 ? void 0 : rawOutput.result.data;
                                        return [3, 6];
                                    case 5:
                                        e_1 = _a.sent();
                                        if (options === null || options === void 0 ? void 0 : options.reportProgress)
                                            options.reportProgress(i, JSON.stringify(e_1));
                                        return [3, 6];
                                    case 6: return [2];
                                }
                            });
                        }); }))];
                    case 1:
                        _a.sent();
                        return [2, output];
                }
            });
        });
    };
    SceneXClient.prototype.describe = function (data, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var rawOutput, simplifiedOutput;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.post('/describe', data)];
                    case 1:
                        rawOutput = _a.sent();
                        if (!((options === null || options === void 0 ? void 0 : options.algorithm) == 'Inception')) return [3, 3];
                        return [4, this.describeVideo(rawOutput, options)];
                    case 2:
                        rawOutput = _a.sent();
                        _a.label = 3;
                    case 3:
                        simplifiedOutput = this.toSimplifiedOutout(rawOutput);
                        if ((options === null || options === void 0 ? void 0 : options.raw) == true)
                            simplifiedOutput.raw = rawOutput;
                        return [2, simplifiedOutput];
                }
            });
        });
    };
    return SceneXClient;
}(HTTPClient_1.HTTPClient));
exports.SceneXClient = SceneXClient;
//# sourceMappingURL=SceneXClient.js.map